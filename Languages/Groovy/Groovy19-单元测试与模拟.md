# 第十八章：单元测试与模拟

---
## 1 单元测试

单元测试对于编程至关重要，不管静态类型语言的编译器执行类型检查多么弱，动态类型语言甚至连这种程度都没有支持，这就是动态语言中单元测试存在的必要原因了。

**作者对单元测试的体会**：

- 促进了我对groovy特性的理解
- 在groovy用户邮件列表中提出的问题帮助修复了一些groovy的bug
- 帮助找到并修复了groovy文档中的一处不一致
- 帮我确保所有示例都是有效的，而且在最新版的groovy中可以很好的工作
- 让我有勇气随意的、随时的重构任何示例，而且让我可以充满自信的说：我对重构会改进代码的结构，但是不会影响预期的行为


###   对Java和Groovy代码执行单元测试

由于Java-Groovy集成，任何基于Java的测试框架和模拟对象的框架(EasyMock、JMock、Mockito)都可以结果Groovy使用

而且在安装Groovy时就集成了JUnit单元测试框架，只需要扩展GroovyTestCase类即可实现测试



### 单元测试必须满足FAIR条件

在编写单元测试时，必须满足FAIR条件：**快速(Fast)、自动化(Automated)、隔离(isolated)、可重复(repeatable).**

- 测试必须要快，随着代码的演进和重构，需要快速得到代码仍然能够满足预期的反馈，如果很慢相比没有开发者会愿意运行它们
- 测试必须是自动化的，手工测试很累，而且容易出错，而相当于减少了投入在重要任务上的时间
- 测试必须隔离，比如碰到1031编译器错误，通常问题就是少了个分号，是吧？这没有实质的帮助，一个小错误级联到一对错误的报告是毫无意义的，我们想要的是因此的bug或错误与失败的测试用例之间的直接关联。
- 测试必须是可重复的，测试一定要能够运行N次，并且得到确定性、可预期的测试结果。如果这次运行失败未作任何修改、下次运行又成功了，这从测试是最坏的。

### 在编写单元测试时，应该考虑3种测试：正面测试、负面测试、异常测试。

- 正面测试可以帮助我们确定代码的表现符合预期，可以在正常的路径上调用这种测试，比如一个账户种存入100美元，然后检查余额是不是这么多了
- 负面测试检查的是，代码能否按照预期的方式处理前置条件无效、无效输入等问题。存入一个负值，看看代码或做什么，如果用户账户关闭，又会做什么
- 异常测试可以帮主确定的是，当异常情况出现时，代码是否会抛出正确的异常，以及表示是否符合预期。如果账户关闭，自动取款操作发起会怎么样？

以这些属于来思考，又助于我们把实现逻辑彻底想清楚，我们不仅要处理实现逻辑的代码，还要考虑常常会让我们陷入困境的**边界条件和极端条件**


---
## 2 模拟测试

对存在大量依赖的代码进行单元测试，就算并非没有可能，也是非常困难的。单元测试有一个优点，它会强制我们让代码单元小一些，代码越小，其内聚就越高。它还会强制我们预期周边的环境解耦。

耦合的两种形式：有的代码会依赖我们的代码，有的代码是我们所依赖的。在对我们的代码进行单元测试时，需要解决这两种耦合。

必须将被测试代码从其所在的应用中分离或者解耦出来，比如位于GUI中的逻辑很难进行单元测试，比如逻辑依赖某个响应很慢的、代码高昂的、不可预测的、或者正处于开发阶段，也无法进行单元测试。

将被测试代码从其所在的应用中分离可以借助存根和模拟来实现。

- 存根：存根用于代替真正的对象，当被测方法调用存根时，它会根据设定好的预期响应简单的应答，之所以要应答是为了满足测试通过的需要。
- 模拟对象：模拟对象所在的事比存根要多得多，它可以帮助确定被测代码按预期方式与依赖或协作对象交互，模拟对象可以记录代码中在该对象的协作对象上进行方法调用的次序和次数。它可以确保传给方法调用的是正确的参数。

存根验证状态，模拟验证行为，当在测试中使用模拟时，它不仅验证状态，也验证了代码与其依赖的交互行为。

我们所以来的代码被称为协作者，我们的代码与协作者合作完成工作，协作者可以是一个组件、对象、层次、子系统。其可能是局部的或者远程的，没有协作者我们的对象无法行使其功能，然而为了满足测试需求，需要替换掉协作者。

模拟用于替换调协作者，其不做任何真正的工作， 而只是简单的像调用它的代码做出预期的响应，以便让测试进行工作。

在Java中可以使用**接口**实现，java框架(EasyMock、JMock、Mockito)简化了模拟，其中一些甚至不需要创建接口就能实现模式(基于代理机制)。


Groovy的动态特性和元编程能力在这方面又很大的优势，Groovy创建模拟有如下范式：

- 方法覆盖
- 分类
 - ExpandoMateClass
 - Expando
 - Map
 - Groovy的Mock Library


