# 迪米特法则

迪米特法则(Law of Demeter 也叫 最少知识原则-Least KnowLedge Principle): **一个类应该对其他的对象有最少的了解，一个类应该对自己需要耦合或调用的类知道的最少，即你内部如何复杂我不管，我只关心你这么多的public方法，我调用实现功能就可以**。

类与类之间的关系越密切，耦合度越大，当一个类发生变化时，对另外一个类的影响也就越大，不稳定性就增加了。

- **只和朋友交流** 
定义为成员变量的或者是方法的输入输出参数才称为成员朋友类，方法内部的类不属于朋友类，方法是一个类的行为，类竟然不知道自己的行为与其他了产生了依赖关系，这是不允许的，严重违反了迪米特法则（JDK中的类除外）。

- **朋友间也是有距离的** 
朋友类之间，尽量暴露少的方法，如果暴露一个方法能完成的功能，就不要暴露两个，一个类公开的public方法越多，设计修改的范围就越大，风险就越大，在设计时，需要反复衡量 ，是否还可以在减少方法和属性，是否可以用private来修饰，是否可以加上final。

- **是自己的就是自己的** 
如果一个方法放在一个类中可以，放在其他类中也可以，那么可以参考这个原则：如果一个方法放在类中，既不增加类的关系，也不对本类产生任何负面影响，就可以放置在本类中。

- **最佳实践**
迪米特法则要求的是类间解耦，但是不要为了原则而项目。

## 实例

例如一个软件的安装过程：有1，2，3步，是交给自己统一调度，还是全部暴露给朋友类呢？

如果接口按照如下设计：

```
    public interface InstallSolfware {
    
        int first();
    
        int second();
    
        int third();
    
    }
```

那么安装的步骤1，2，3都将交给调用端调用，这显然是对的，如果软件升级安装的步骤变化了，同样需要调用端进行更改，这就增加不不需要的风险：

```
    public interface InstallWizard {
    
        void runInstallWizard();
    
    }
```

所以只需要暴露一个安装的方法即可，至于调用的步骤自己内部进行封装：

```
    public class InstallWizardImpl implements InstallWizard{
    
    
        @Override
        public void runInstallWizard() {
            first();
            second();
            third();
        }
    
        private int third() {
    
        }
    
        private int second() {
    
        }
    
        private int first() {
        }
    }
```

总结：在应用开发中，最难的不是完成应用的开发，而是在后续的升级，维护过程中，让应用系统能够拥抱变化，拥抱变化也就意味着在满足需求的情况下不破还系统的稳定性并且保持高可扩展性，高内聚，低耦合，在经历了各个版本的变更之后依然保持清晰，灵活，稳定的系统架构。