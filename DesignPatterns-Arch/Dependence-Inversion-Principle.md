# 依赖倒置原则-Dependence Inversion Principle

依赖倒置原则(Dependence Inversion Principle)：**1，高层模块不应该依赖其低层模块，两者都因该依赖其抽象；2，抽象不应该依赖细节；3，细节应该依赖抽象**。

在Java语言中，抽象即使接口或者抽象类，这两者是不能被直接抽象画的，细节就是实现类，实现了接口或者抽象类的方法就是细节，其特点就是可以被实例化；高层模块就是调用端，底层模块就是实现类，依赖倒置的原则在Java语言中的体现就是：**模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的**，讲白了就是**面向接口编程，面向抽象编程**。

依赖倒置原则有如下要求：

*   模块之间的依赖通过抽象发生，实现类之间不应该直接发生依赖关系，其依赖还是通过接口与抽象类发生的
*   抽象类或者接口不应该依赖实现类
*   实现类依赖于接口与抽象类

**模块之间只需要定义相互的依赖接口就可以进行开发，从而实现并行开发，独立模块也可以进行独立测试,这一点是很重要的**

一个模块依赖于另一个模块，或者一个类的功能的实现依赖于另外一个类，那么这时就发生了依赖关系，应该做到的是类与类之间的相互声明尽量使用抽象类或者接口，那么如何实现依赖的注入呢，即如何把具体的实现设置给声明的依赖呢？

## 注入依赖

*   构造函数传递对象
*   利用set方法传入依赖对象
*   接口声明依赖对象，也叫接口注入
*   注解注入

## 最佳实践

*   每个类都应该有其接口或者抽象，或者两者都有，**有了抽象才可以依赖倒置**
*   变量的表面类型尽量使其接口或者抽象
*   任何类都不应该从具体的类派生
*   尽量不覆写父类中已实现的方法，
*   结合里氏替换原则使用，结合里氏替换原则所得：接口负责定义public的属性和方法，并负责定义与其他对象的依赖关系，抽象类辅助公共部件(接口的框架实现)的实现，实现类准确的实现业务逻辑，同时适当的对父类进行细化

## 理清倒置与正置

依赖正置就是类与类之间的关系是实实在在的实现类，也就是面向实现编程，这符合人的正常思维，要开奔驰车就需要奔驰车，而编程确是对具体事务的抽象，有了接口与实现类就有了抽象与具体，然后根据业务定义相互之间的依赖关系。


## 实例 1

司机与汽车的例子，司机不仅仅可以驾驶宝马，而且可以驾驶很多车：

### 依赖于具体编程

具体的司机依赖具体的车子，司机依赖奔驰，这就造成了司机只能开奔驰车，完全无发并行开发，必须有了车子才能继续开发驾驶员!!!，而且司机只能驾驶奔驰车。

```
    public class Benz {
    
        public void run() {
            System.out.println("奔驰车子启动");
        }
    }
    
    public class Driver {
    
        public void driver(Benz benz) {
            benz.run();
        }
    }
    
    public class Client {
        public static void main(String[] args) {
    
            Driver driver = new Driver();
            driver.driver(new Benz());
    
        }
    }
```

## 依赖于抽象编程

模块之间通过接口实现依赖，定义锲约即可以达到并行开发，其次Driver不在依赖于具体的奔驰，由于他依赖的是抽象，在具体的实现中，它可以开各种车子。这就给体统带来了灵活性。

```
    public interface ICar {
    
        void run();
    }
    
    public interface IDriver {
    
        void driver(ICar car);
    
    }
```

## 实例 2

前面的ImageLoader中，首先ImageLoader依赖于具体的MemoryCache来实现图片的内存缓存，但是这样一来ImageLoader就有了很大的局限性，它只能依赖于MemoryCache，如果以后要实现其他的图片缓存，那么必须对ImageLoader进行改造，这样的设计就带来的系统的不稳定性，而通过抽象缓存行为，让ImageLoader依赖抽象的ImageCache接口，从而实现了图片缓存的灵活配置，也增强了这个框架的稳定性，从而不会因为一个小小的需求增加而需要对原有的代码进行大的修改。