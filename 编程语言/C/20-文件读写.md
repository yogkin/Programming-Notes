#  C语言文件操作

---
## 1 文件概念

文件是程序设计的一个重要概念，一般指存储在外部介质上的数据集合。

文件包括程序文件和数据文件

- 程序文件：包括程序源文件(.c)、目标文件(.obj)、可执行文件(.exe)等，这种文件的内容都是程序代码。
- 数据文件：文件的内容不是程序，而是供程序运行时读写的数据。

为了简化用户输入输出据设备的操作，使用户不必区分各种输入输出设备的区别，操作系统把各种输入输出设备都抽象为文件来处理。

**数据流**：输入输出是数据的传送过程，数据如流水一样从一端传送到另一端，因此常将输入输出形象的称为流，即数据流。

### 文件名

一个文件要有一个唯一的标识符号，以便于识别和引用。

```
        如：`C:\C\Temp\file1.dat`，`C:\C\Temp`表示文件路径、`file1`表示文件名主干、`.dat`表示文件后缀
```

### 分类

根据数据的组织形式，数据可以分为文本文件和二进制文件,

数据在内存中是以二进制形式存储的、如果不加转换输出到外部存储，就是二进制文件，
可以认为其就是内存数据的映射，所以也称为映像文件(image file)。

### 文件缓冲区

ANSI C标准采用**文件缓冲文件系统**来处理数据，
所谓文件缓冲文件系统是指系统自动的在内存区为程序中的每个正在使用的文件开辟一个文件缓冲区，
从内存想磁盘输出数据必须先送到文件缓冲区，装满缓冲区后一起送到磁盘。

### 文件指针

文件缓冲系统中关键的概念是**文件类型指针**，简称**文件指针**，每个被使用的文件都开辟一个相应的文件信息保存区，
用于存放文件的有关信息(文件名、状态等)，这些信息都保存在一个结构体中，该结构体由系统声明，名为FILE。

---
## 2 标准文件

C语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。

标准文件    |   文件指针    |   设备
---|--|---
标准输入    |   stdin   |   键盘
标准输出    |   stdout    |   屏幕
标准错误    |   stderr    |   你的屏幕

`fprintf(stderr, "Value of errno: %d\n", 1);`：表示在屏幕上输出错误信息：Value of errno: 1

---
## 3 文件操作相关函数说明

### 打开关闭文件

- `FILE *fopen( const char * filename, const char * mode );`
- `int fclose( FILE *fp );`

fopen的mode说明：

模式    | 描述
--- | ---
`r`     | 打开一个已有的文本文件，允许读取文件。
`w`     | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。
`a`     | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。
`r+`     | 打开一个文本文件，允许读写文件。
`w+`     | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。
`a+`     | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。

如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

    "rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"

### 顺序读写文件

```c
int    fgetc (FILE *);        失败返回EFO(-1)
int    fputc (int, FILE *);
char * gets (char *);
int    puts (const char *);
getc(FILE *)
putc(char,FILE *)
fscanf (FILE *, const char *, ...);   格式化输入
int fprintf (FILE *, const char *, ...); 格式化输出
```
### 读写二进制文件

```
size_t fread (void * buffer, size_t size, size_t count , FILE * fp); 
size_t fwrite (const void *, size_t, size_t, FILE *);
```

参数说明，以`fread(f,4,10,fp)`为例：f是一个float类型数组名(代表数组首地址)，这个函数从fp所指向的文件读入10个四个字节的数据，存储在f数组中。

### 随机读写文件

随机访问不是按照数据在文件中的物理位置次序进行读写，而是可以对任意位置上的数据进行访问

```c
//函数
int    fseek (FILE *, long, int); 移动文件位置标记
long   ftell (FILE *);   获取文件当前标记的位置，配合SEEK_END用以用于获取文件大小
void   rewind (FILE *);  文件标记回到开始的位置

//示例
fseek(fp,100L,0)    将文件位置移动到离文件开头100个字节的位置
fseek(fp,100L,1)    将文件位置向前移动到离文件当前位置100个字节的位置
fseek(fp,-100L,2)   将文件位置向左移动到离文件末尾位置100个字节的位置
```

### 错误处理

```c
ferror(FILE *)：如果ferror返回值为0，表示未出错，如果返回一个非0值，表示出错。
clearerr(FILE *)：使文件错误标志和文件结束标志为0
```

---
## 4 路径

### Linux

`unistd.h`中的`getcwd`函数：

getcwd()会将当前的工作目录绝对路径复制到参数buf所指的内存空间，参数size为buf的空间大小。
在调用此函数时，buf所指的内存空间要足够大，若工作目录绝对路径的字符串长度超过参数size大小，则回值NULL，
errno的值则为ERANGE。倘若参数buf为NULL，getcwd()会依参数size的大小自动配置内存(使用malloc())，
如果参数size也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，进
程可以在使用完此字符串后利用free()来释放此空间。
当函数执行成功则将结果复制到参数buf所指的内存空间，或是返回自动配置的字符串指针。失败返回NULL，错误代码存于errno。


### Windows

`direct.h`中的`_getcwd`函数

具体参考：[C语言windows目录操作](http://blog.csdn.net/yangalbert/article/details/7455241)