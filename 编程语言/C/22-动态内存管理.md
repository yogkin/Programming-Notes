# 动态内存管理

---
## 1  动态内存管理相关函数

C语言为内存的分配和管理提供了几个函数。这些函数可以在` <stdlib.h> `头文件中找到。函数说明：

序号|函数和描述
---|---
`void *calloc(int num, int size);`|在内存中动态地分配num个长度为size的连续空间，并将每一个字节都初始化为0。所以它的结果是分配了`num*size`个字节长度的内存空间，并且每个字节的值都是0。如果分配失败则返回NULL。
`void free(void *address); `|该函数释放address所指向的内存块,释放的是动态分配的内存空间。
`void *malloc(int num); `|在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。如果分配失败则返回NULL。
`void *realloc(void *address, int newsize); `|该函数重新分配内存，把内存**扩展或缩小**到`newsize`。


---
## 2 内存的限制

C语言内存分配：

1. 栈区(stack)：windows下，栈内存分配2M（确定的常数），如果超出了限制，程序提示stack overflow错误
1. 堆区(heap)：程序员手动分配释放，操作系统80%内存
1. 全局区或静态区
1. 字符常量区
1. 程序代码区

下面程序将倒置栈内存溢出，一般系统分配给程序的栈内存空间是很小的，如果需要使用较大的内存控件，需要使用堆内存空间。

```
int main(){
    //下面将导致40M的栈内存空间分配
    //静态内存分配
    int a[1024 * 1024 * 10];////stack overflow错误，栈溢出
    return 0;
}
```

栈内存分配属于**静态内存分配**，而使用动态内存管理，可以在运行期申请不确定的内存空间，属于**动态内存分配**，这提高了程序的灵活性。
动态分配的内存需要手动释放，释放之后这些内存还可以被重新使用。

---
## 3 realloc

重新分配内存的两种情况：缩小和扩大，缩小的那一部分数据会丢失，扩大有一下几种情况：


1. 如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，`realloc`返回原指针
2. 如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据将被释放掉，返回新的内存地址，所以释放内存时，只需要释放最后一次指向内存的指针即可
3. 如果申请失败，返回NULL，原来的指针仍然有效

```
    int* p = calloc(len, sizeof(int));    
    int* p2 = realloc(p, sizeof(int) * (len + addLen));
    if (p2 == NULL){
        printf("重新分配失败");
    }
```

---
## 4 `void*`类型

`calloc`等函数返回值为void指针类型， c99允许使用void指针类型，void不指向任何类型的数据，应该把其理解为执行向空类型或者不指向确定的类型的数据