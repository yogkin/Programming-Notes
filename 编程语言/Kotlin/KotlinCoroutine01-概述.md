# 协程

---
## 1 协程的概念

### 子程序

子程序即函数，函数调用是通过调用栈来实现的，而栈只有一个入口和一个出口，所以可以认为函数的调用是线性的，调用顺序非常明确

### 协程

- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，可以认为协程中函数可以有多个入口。
- 协程存在的意义：**让异步代码看上去像同步代码，直接自然易懂** 。至于它如何做到这一点，可能各家的语言实现各有不同。

协程与线程的区别是：

- 一个协程可以有多个入口，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。
- 线程是由CPU的调度，是一种抢占式调度，而协程的调度是非抢占式的。
- 协程一般是由编译器实现的，而线程是由系统CPU调度的，线程是更加底层的东西，而协程是更高一层的封装。

---
## 2 kotlin协程

kotlin协程的异步需要依赖比它更底层的 API 支持，那么在Kotlin当中，这个所谓的底层API就非线程莫属了。

### 协程概念和作用

一些耗时操作(网络IO、文件IO、CPU/GPU密集型任务)会阻塞线程直到操作完成，Kotlin的协程提供一种避免阻塞且更廉价可控的操作: 协程挂起(coroutine suspension)，协程将复杂异步操作放入底层库中，**程序逻辑可顺序表达**，以此简化异步编程，该底层库将用户代码包装为**回调/订阅**事件在**不同线程(甚至不同机器)调度执行**。

### 线程阻塞和协程挂起的区别

协程是通过编译技术实现(不需要虚拟机VM/操作系统OS的支持)，通过插入相关代码来生效！ 与之相反，线程/进程是需要虚拟机VM/操作系统OS的支持，通过调度CPU执行生效!

- **线程阻塞的代价昂贵**， 尤其在高负载时的可用线程很少，阻塞线程会导致一些重要任务缺少可用线程而被延迟!

- 协程挂起几乎无代价，无需上下文切换或涉及OS， 最重要的是，协程挂起可由用户控制，可决定挂起时发生什么，并根据需求优化/记录日志/拦截，另一个不同之处：**协程不能在随机指令中挂起，只能在挂起点挂起(调用标记函数)**


### Kotlin 协程的实验性状态

Kotlin 协程目前处于实验性状态，其类库放在 `kotlin.coroutines.experimental` 实验包下。当协程的实验性状态解除时，最终的 API 会移动到 `kotlin.coroutines`，但是实验包会被保留（可能在一个单独的构件中）以实现向后兼容。

---
## 3 理解

协程函数具有多个入口(每个挂起点)，可以理解为协程把单个协程函数切割成多个独立的代码片段(block) ，这些被切割的函数可以运行在不同的线程，然后利用一个调度机制(比如状态机)控制下一步执行哪个方法，这样就可以在 Java 中实现协程，当然这是编译器的工作，作为开发者在开发过程中并无感知。